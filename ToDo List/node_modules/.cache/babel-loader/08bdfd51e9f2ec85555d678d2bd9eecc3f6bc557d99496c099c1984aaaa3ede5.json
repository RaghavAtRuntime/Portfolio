{"ast":null,"code":"import quote from \"../modules/quote.js\";\nimport validateAndCoerceTypes from \"../lib/validateAndCoerceTypes.js\";\nconst DEBOUNCE_TIME = 50;\nconst slugMap = new Map();\nexport default function quoteCombine(query, queryOptionsOverrides = {}, moduleOptions) {\n  const symbol = query;\n  if (typeof symbol !== \"string\") throw new Error(\"quoteCombine expects a string query parameter, received: \" + JSON.stringify(symbol, null, 2));\n  validateAndCoerceTypes({\n    source: \"quoteCombine\",\n    type: \"options\",\n    object: queryOptionsOverrides,\n    schemaKey: \"#/definitions/QuoteOptions\",\n    options: this._opts.validation\n  });\n  // Make sure we only combine requests with same options\n  const slug = JSON.stringify(queryOptionsOverrides);\n  let entry = slugMap.get(slug);\n  if (!entry) {\n    entry = {\n      timeout: null,\n      queryOptionsOverrides,\n      symbols: new Map()\n    };\n    slugMap.set(slug, entry);\n  }\n  if (entry.timeout) clearTimeout(entry.timeout);\n  const thisQuote = quote.bind(this);\n  return new Promise((resolve, reject) => {\n    let symbolPromiseCallbacks = entry.symbols.get(symbol);\n    /* istanbul ignore else */\n    if (!symbolPromiseCallbacks) {\n      symbolPromiseCallbacks = [];\n      entry.symbols.set(symbol, symbolPromiseCallbacks);\n    }\n    symbolPromiseCallbacks.push({\n      resolve,\n      reject\n    });\n    entry.timeout = setTimeout(() => {\n      slugMap.delete(slug);\n      const symbols = Array.from(entry.symbols.keys());\n      // @ts-ignore\n      thisQuote(symbols, queryOptionsOverrides, moduleOptions).then(results => {\n        for (let result of results) {\n          for (let promise of entry.symbols.get(result.symbol)) {\n            promise.resolve(result);\n            promise.resolved = true;\n          }\n        }\n        // Check for symbols we asked for and didn't get back,\n        // e.g. non-existant symbols (#150)\n        for (let [symbol, promises] of entry.symbols) {\n          for (let promise of promises) {\n            if (!promise.resolved) {\n              promise.resolve(undefined);\n            }\n          }\n        }\n      }).catch(error => {\n        for (let symbolPromiseCallbacks of entry.symbols.values()) for (let promise of symbolPromiseCallbacks) promise.reject(error);\n      });\n    }, DEBOUNCE_TIME);\n  });\n}","map":{"version":3,"names":["quote","validateAndCoerceTypes","DEBOUNCE_TIME","slugMap","Map","quoteCombine","query","queryOptionsOverrides","moduleOptions","symbol","Error","JSON","stringify","source","type","object","schemaKey","options","_opts","validation","slug","entry","get","timeout","symbols","set","clearTimeout","thisQuote","bind","Promise","resolve","reject","symbolPromiseCallbacks","push","setTimeout","delete","Array","from","keys","then","results","result","promise","resolved","promises","undefined","catch","error","values"],"sources":["/Users/raghavsinha/sandbox/node_modules/yahoo-finance2/dist/esm/src/other/quoteCombine.js"],"sourcesContent":["import quote from \"../modules/quote.js\";\nimport validateAndCoerceTypes from \"../lib/validateAndCoerceTypes.js\";\nconst DEBOUNCE_TIME = 50;\nconst slugMap = new Map();\nexport default function quoteCombine(query, queryOptionsOverrides = {}, moduleOptions) {\n    const symbol = query;\n    if (typeof symbol !== \"string\")\n        throw new Error(\"quoteCombine expects a string query parameter, received: \" +\n            JSON.stringify(symbol, null, 2));\n    validateAndCoerceTypes({\n        source: \"quoteCombine\",\n        type: \"options\",\n        object: queryOptionsOverrides,\n        schemaKey: \"#/definitions/QuoteOptions\",\n        options: this._opts.validation,\n    });\n    // Make sure we only combine requests with same options\n    const slug = JSON.stringify(queryOptionsOverrides);\n    let entry = slugMap.get(slug);\n    if (!entry) {\n        entry = {\n            timeout: null,\n            queryOptionsOverrides,\n            symbols: new Map(),\n        };\n        slugMap.set(slug, entry);\n    }\n    if (entry.timeout)\n        clearTimeout(entry.timeout);\n    const thisQuote = quote.bind(this);\n    return new Promise((resolve, reject) => {\n        let symbolPromiseCallbacks = entry.symbols.get(symbol);\n        /* istanbul ignore else */\n        if (!symbolPromiseCallbacks) {\n            symbolPromiseCallbacks = [];\n            entry.symbols.set(symbol, symbolPromiseCallbacks);\n        }\n        symbolPromiseCallbacks.push({ resolve, reject });\n        entry.timeout = setTimeout(() => {\n            slugMap.delete(slug);\n            const symbols = Array.from(entry.symbols.keys());\n            // @ts-ignore\n            thisQuote(symbols, queryOptionsOverrides, moduleOptions)\n                .then((results) => {\n                for (let result of results) {\n                    for (let promise of entry.symbols.get(result.symbol)) {\n                        promise.resolve(result);\n                        promise.resolved = true;\n                    }\n                }\n                // Check for symbols we asked for and didn't get back,\n                // e.g. non-existant symbols (#150)\n                for (let [symbol, promises] of entry.symbols) {\n                    for (let promise of promises) {\n                        if (!promise.resolved) {\n                            promise.resolve(undefined);\n                        }\n                    }\n                }\n            })\n                .catch((error) => {\n                for (let symbolPromiseCallbacks of entry.symbols.values())\n                    for (let promise of symbolPromiseCallbacks)\n                        promise.reject(error);\n            });\n        }, DEBOUNCE_TIME);\n    });\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}