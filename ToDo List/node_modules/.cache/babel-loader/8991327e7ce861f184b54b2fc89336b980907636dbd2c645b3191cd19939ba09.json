{"ast":null,"code":"/*\n * moduleExec(options: ModuleExecOptions)\n *\n * 1. Query Stage\n *   1. Validate user-supplied module params, e.g. { period: '1d' }\n *   2. Merge query params: (module defaults, user-supplied overrides, etc)\n *   3. Optionally transform query params\n *\n * 2. Call lib/yahooFinanceFetch\n *\n * 3. Result Stage\n *   1. Optional transform the result\n *   2. Validate the result and coerce types\n *\n * Further info below, inline.\n */\nimport validateAndCoerceTypes from \"./validateAndCoerceTypes.js\";\nimport csv2json from \"./csv2json.js\";\nasync function moduleExec(opts) {\n  var _a;\n  const queryOpts = opts.query;\n  const moduleOpts = opts.moduleOptions;\n  const moduleName = opts.moduleName;\n  const resultOpts = opts.result;\n  if (queryOpts.assertSymbol) {\n    const symbol = queryOpts.assertSymbol;\n    if (typeof symbol !== \"string\") throw new Error(`yahooFinance.${moduleName}() expects a single string symbol as its ` + `query, not a(n) ${typeof symbol}: ${JSON.stringify(symbol)}`);\n  }\n  // Check that query options passed by the user are valid for this module\n  validateAndCoerceTypes({\n    source: moduleName,\n    type: \"options\",\n    object: (_a = queryOpts.overrides) !== null && _a !== void 0 ? _a : {},\n    schemaKey: queryOpts.schemaKey,\n    options: this._opts.validation\n  });\n  let queryOptions = {\n    ...queryOpts.defaults,\n    // Module defaults e.g. { period: '1wk', lang: 'en' }\n    ...queryOpts.runtime,\n    // Runtime params e.g. { q: query }\n    ...queryOpts.overrides // User supplied options that override above\n  };\n  /*\n   * Called with the merged (defaults,runtime,overrides) before running\n   * the query.  Useful to transform options we allow but not Yahoo, e.g.\n   * allow a \"2020-01-01\" date but transform this to a UNIX epoch.\n   */\n  if (queryOpts.transformWith) queryOptions = queryOpts.transformWith(queryOptions);\n  // this._fetch is lib/yahooFinanceFetch\n  let result = await this._fetch(queryOpts.url, queryOptions, moduleOpts, queryOpts.fetchType, queryOpts.needsCrumb);\n  if (queryOpts.fetchType === \"csv\") result = csv2json(result);\n  /*\n   * Mutate the Yahoo result *before* validating and coercion.  Mostly used\n   * to e.g. throw if no (resault.returnField) and return result.returnField.\n   */\n  if (opts.result.transformWith) result = opts.result.transformWith(result);\n  const validateResult = !moduleOpts || moduleOpts.validateResult === undefined || moduleOpts.validateResult === true;\n  const validationOpts = {\n    ...this._opts.validation,\n    // Set logErrors=false if validateResult=false\n    logErrors: validateResult ? this._opts.validation.logErrors : false\n  };\n  /*\n   * Validate the returned result (after transforming, above) and coerce types.\n   *\n   * The coersion works as follows: if we're expecting a \"Date\" type, but Yahoo\n   * gives us { raw: 1231421524, fmt: \"2020-01-01\" }, we'll return that as\n   * `new Date(1231421524 * 1000)`.\n   *\n   * Beyond that, ensures that user won't process unexpected data, in two\n   * cases:\n   *\n   * a) Missing required properties or unexpected additional properties\n   * b) A total new change in format that we really have no idea what to do\n   *    with, e.g. a new kind of Date that we've never seen before and\n   *\n   * The idea is that if you receive a result, it's safe to use / store in\n   * database, etc.  Otherwise you'll receive an error.\n   */\n  try {\n    validateAndCoerceTypes({\n      source: moduleName,\n      type: \"result\",\n      object: result,\n      schemaKey: resultOpts.schemaKey,\n      options: validationOpts\n    });\n  } catch (error) {\n    if (validateResult) throw error;\n  }\n  return result;\n}\nexport default moduleExec;","map":{"version":3,"names":["validateAndCoerceTypes","csv2json","moduleExec","opts","_a","queryOpts","query","moduleOpts","moduleOptions","moduleName","resultOpts","result","assertSymbol","symbol","Error","JSON","stringify","source","type","object","overrides","schemaKey","options","_opts","validation","queryOptions","defaults","runtime","transformWith","_fetch","url","fetchType","needsCrumb","validateResult","undefined","validationOpts","logErrors","error"],"sources":["/Users/raghavsinha/sandbox/node_modules/yahoo-finance2/dist/esm/src/lib/moduleExec.js"],"sourcesContent":["/*\n * moduleExec(options: ModuleExecOptions)\n *\n * 1. Query Stage\n *   1. Validate user-supplied module params, e.g. { period: '1d' }\n *   2. Merge query params: (module defaults, user-supplied overrides, etc)\n *   3. Optionally transform query params\n *\n * 2. Call lib/yahooFinanceFetch\n *\n * 3. Result Stage\n *   1. Optional transform the result\n *   2. Validate the result and coerce types\n *\n * Further info below, inline.\n */\nimport validateAndCoerceTypes from \"./validateAndCoerceTypes.js\";\nimport csv2json from \"./csv2json.js\";\nasync function moduleExec(opts) {\n    var _a;\n    const queryOpts = opts.query;\n    const moduleOpts = opts.moduleOptions;\n    const moduleName = opts.moduleName;\n    const resultOpts = opts.result;\n    if (queryOpts.assertSymbol) {\n        const symbol = queryOpts.assertSymbol;\n        if (typeof symbol !== \"string\")\n            throw new Error(`yahooFinance.${moduleName}() expects a single string symbol as its ` +\n                `query, not a(n) ${typeof symbol}: ${JSON.stringify(symbol)}`);\n    }\n    // Check that query options passed by the user are valid for this module\n    validateAndCoerceTypes({\n        source: moduleName,\n        type: \"options\",\n        object: (_a = queryOpts.overrides) !== null && _a !== void 0 ? _a : {},\n        schemaKey: queryOpts.schemaKey,\n        options: this._opts.validation,\n    });\n    let queryOptions = {\n        ...queryOpts.defaults, // Module defaults e.g. { period: '1wk', lang: 'en' }\n        ...queryOpts.runtime, // Runtime params e.g. { q: query }\n        ...queryOpts.overrides, // User supplied options that override above\n    };\n    /*\n     * Called with the merged (defaults,runtime,overrides) before running\n     * the query.  Useful to transform options we allow but not Yahoo, e.g.\n     * allow a \"2020-01-01\" date but transform this to a UNIX epoch.\n     */\n    if (queryOpts.transformWith)\n        queryOptions = queryOpts.transformWith(queryOptions);\n    // this._fetch is lib/yahooFinanceFetch\n    let result = await this._fetch(queryOpts.url, queryOptions, moduleOpts, queryOpts.fetchType, queryOpts.needsCrumb);\n    if (queryOpts.fetchType === \"csv\")\n        result = csv2json(result);\n    /*\n     * Mutate the Yahoo result *before* validating and coercion.  Mostly used\n     * to e.g. throw if no (resault.returnField) and return result.returnField.\n     */\n    if (opts.result.transformWith)\n        result = opts.result.transformWith(result);\n    const validateResult = !moduleOpts ||\n        moduleOpts.validateResult === undefined ||\n        moduleOpts.validateResult === true;\n    const validationOpts = {\n        ...this._opts.validation,\n        // Set logErrors=false if validateResult=false\n        logErrors: validateResult ? this._opts.validation.logErrors : false,\n    };\n    /*\n     * Validate the returned result (after transforming, above) and coerce types.\n     *\n     * The coersion works as follows: if we're expecting a \"Date\" type, but Yahoo\n     * gives us { raw: 1231421524, fmt: \"2020-01-01\" }, we'll return that as\n     * `new Date(1231421524 * 1000)`.\n     *\n     * Beyond that, ensures that user won't process unexpected data, in two\n     * cases:\n     *\n     * a) Missing required properties or unexpected additional properties\n     * b) A total new change in format that we really have no idea what to do\n     *    with, e.g. a new kind of Date that we've never seen before and\n     *\n     * The idea is that if you receive a result, it's safe to use / store in\n     * database, etc.  Otherwise you'll receive an error.\n     */\n    try {\n        validateAndCoerceTypes({\n            source: moduleName,\n            type: \"result\",\n            object: result,\n            schemaKey: resultOpts.schemaKey,\n            options: validationOpts,\n        });\n    }\n    catch (error) {\n        if (validateResult)\n            throw error;\n    }\n    return result;\n}\nexport default moduleExec;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}