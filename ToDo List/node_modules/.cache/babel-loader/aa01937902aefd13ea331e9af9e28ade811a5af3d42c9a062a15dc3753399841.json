{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nconst codegen_1 = require(\"../../compile/codegen\");\nconst util_1 = require(\"../../compile/util\");\nconst equal_1 = require(\"../../runtime/equal\");\nconst error = {\n  message: \"must be equal to one of the allowed values\",\n  params: ({\n    schemaCode\n  }) => (0, codegen_1._)`{allowedValues: ${schemaCode}}`\n};\nconst def = {\n  keyword: \"enum\",\n  schemaType: \"array\",\n  $data: true,\n  error,\n  code(cxt) {\n    const {\n      gen,\n      data,\n      $data,\n      schema,\n      schemaCode,\n      it\n    } = cxt;\n    if (!$data && schema.length === 0) throw new Error(\"enum must have non-empty array\");\n    const useLoop = schema.length >= it.opts.loopEnum;\n    const eql = (0, util_1.useFunc)(gen, equal_1.default);\n    let valid;\n    if (useLoop || $data) {\n      valid = gen.let(\"valid\");\n      cxt.block$data(valid, loopEnum);\n    } else {\n      /* istanbul ignore if */\n      if (!Array.isArray(schema)) throw new Error(\"ajv implementation error\");\n      const vSchema = gen.const(\"vSchema\", schemaCode);\n      valid = (0, codegen_1.or)(...schema.map((_x, i) => equalCode(vSchema, i)));\n    }\n    cxt.pass(valid);\n    function loopEnum() {\n      gen.assign(valid, false);\n      gen.forOf(\"v\", schemaCode, v => gen.if((0, codegen_1._)`${eql}(${data}, ${v})`, () => gen.assign(valid, true).break()));\n    }\n    function equalCode(vSchema, i) {\n      const sch = schema[i];\n      return typeof sch === \"object\" && sch !== null ? (0, codegen_1._)`${eql}(${data}, ${vSchema}[${i}])` : (0, codegen_1._)`${data} === ${sch}`;\n    }\n  }\n};\nexports.default = def;","map":{"version":3,"names":["codegen_1","require","util_1","equal_1","error","message","params","schemaCode","_","def","keyword","schemaType","$data","code","cxt","gen","data","schema","it","length","Error","useLoop","opts","loopEnum","eql","useFunc","default","valid","let","block$data","Array","isArray","vSchema","const","or","map","_x","i","equalCode","pass","assign","forOf","v","if","break","sch","exports"],"sources":["/Users/raghavsinha/sandbox/node_modules/yahoo-finance2/node_modules/ajv/lib/vocabularies/validation/enum.ts"],"sourcesContent":["import type {CodeKeywordDefinition, ErrorObject, KeywordErrorDefinition} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, or, Name, Code} from \"../../compile/codegen\"\nimport {useFunc} from \"../../compile/util\"\nimport equal from \"../../runtime/equal\"\n\nexport type EnumError = ErrorObject<\"enum\", {allowedValues: any[]}, any[] | {$data: string}>\n\nconst error: KeywordErrorDefinition = {\n  message: \"must be equal to one of the allowed values\",\n  params: ({schemaCode}) => _`{allowedValues: ${schemaCode}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"enum\",\n  schemaType: \"array\",\n  $data: true,\n  error,\n  code(cxt: KeywordCxt) {\n    const {gen, data, $data, schema, schemaCode, it} = cxt\n    if (!$data && schema.length === 0) throw new Error(\"enum must have non-empty array\")\n    const useLoop = schema.length >= it.opts.loopEnum\n    const eql = useFunc(gen, equal)\n    let valid: Code\n    if (useLoop || $data) {\n      valid = gen.let(\"valid\")\n      cxt.block$data(valid, loopEnum)\n    } else {\n      /* istanbul ignore if */\n      if (!Array.isArray(schema)) throw new Error(\"ajv implementation error\")\n      const vSchema = gen.const(\"vSchema\", schemaCode)\n      valid = or(...schema.map((_x: unknown, i: number) => equalCode(vSchema, i)))\n    }\n    cxt.pass(valid)\n\n    function loopEnum(): void {\n      gen.assign(valid, false)\n      gen.forOf(\"v\", schemaCode as Code, (v) =>\n        gen.if(_`${eql}(${data}, ${v})`, () => gen.assign(valid, true).break())\n      )\n    }\n\n    function equalCode(vSchema: Name, i: number): Code {\n      const sch = schema[i]\n      return typeof sch === \"object\" && sch !== null\n        ? _`${eql}(${data}, ${vSchema}[${i}])`\n        : _`${data} === ${sch}`\n    }\n  },\n}\n\nexport default def\n"],"mappings":";;;;;AAEA,MAAAA,SAAA,GAAAC,OAAA;AACA,MAAAC,MAAA,GAAAD,OAAA;AACA,MAAAE,OAAA,GAAAF,OAAA;AAIA,MAAMG,KAAK,GAA2B;EACpCC,OAAO,EAAE,4CAA4C;EACrDC,MAAM,EAAEA,CAAC;IAACC;EAAU,CAAC,KAAK,IAAAP,SAAA,CAAAQ,CAAC,oBAAmBD,UAAU;CACzD;AAED,MAAME,GAAG,GAA0B;EACjCC,OAAO,EAAE,MAAM;EACfC,UAAU,EAAE,OAAO;EACnBC,KAAK,EAAE,IAAI;EACXR,KAAK;EACLS,IAAIA,CAACC,GAAe;IAClB,MAAM;MAACC,GAAG;MAAEC,IAAI;MAAEJ,KAAK;MAAEK,MAAM;MAAEV,UAAU;MAAEW;IAAE,CAAC,GAAGJ,GAAG;IACtD,IAAI,CAACF,KAAK,IAAIK,MAAM,CAACE,MAAM,KAAK,CAAC,EAAE,MAAM,IAAIC,KAAK,CAAC,gCAAgC,CAAC;IACpF,MAAMC,OAAO,GAAGJ,MAAM,CAACE,MAAM,IAAID,EAAE,CAACI,IAAI,CAACC,QAAQ;IACjD,MAAMC,GAAG,GAAG,IAAAtB,MAAA,CAAAuB,OAAO,EAACV,GAAG,EAAEZ,OAAA,CAAAuB,OAAK,CAAC;IAC/B,IAAIC,KAAW;IACf,IAAIN,OAAO,IAAIT,KAAK,EAAE;MACpBe,KAAK,GAAGZ,GAAG,CAACa,GAAG,CAAC,OAAO,CAAC;MACxBd,GAAG,CAACe,UAAU,CAACF,KAAK,EAAEJ,QAAQ,CAAC;KAChC,MAAM;MACL;MACA,IAAI,CAACO,KAAK,CAACC,OAAO,CAACd,MAAM,CAAC,EAAE,MAAM,IAAIG,KAAK,CAAC,0BAA0B,CAAC;MACvE,MAAMY,OAAO,GAAGjB,GAAG,CAACkB,KAAK,CAAC,SAAS,EAAE1B,UAAU,CAAC;MAChDoB,KAAK,GAAG,IAAA3B,SAAA,CAAAkC,EAAE,EAAC,GAAGjB,MAAM,CAACkB,GAAG,CAAC,CAACC,EAAW,EAAEC,CAAS,KAAKC,SAAS,CAACN,OAAO,EAAEK,CAAC,CAAC,CAAC,CAAC;;IAE9EvB,GAAG,CAACyB,IAAI,CAACZ,KAAK,CAAC;IAEf,SAASJ,QAAQA,CAAA;MACfR,GAAG,CAACyB,MAAM,CAACb,KAAK,EAAE,KAAK,CAAC;MACxBZ,GAAG,CAAC0B,KAAK,CAAC,GAAG,EAAElC,UAAkB,EAAGmC,CAAC,IACnC3B,GAAG,CAAC4B,EAAE,CAAC,IAAA3C,SAAA,CAAAQ,CAAC,IAAGgB,GAAG,IAAIR,IAAI,KAAK0B,CAAC,GAAG,EAAE,MAAM3B,GAAG,CAACyB,MAAM,CAACb,KAAK,EAAE,IAAI,CAAC,CAACiB,KAAK,EAAE,CAAC,CACxE;IACH;IAEA,SAASN,SAASA,CAACN,OAAa,EAAEK,CAAS;MACzC,MAAMQ,GAAG,GAAG5B,MAAM,CAACoB,CAAC,CAAC;MACrB,OAAO,OAAOQ,GAAG,KAAK,QAAQ,IAAIA,GAAG,KAAK,IAAI,GAC1C,IAAA7C,SAAA,CAAAQ,CAAC,IAAGgB,GAAG,IAAIR,IAAI,KAAKgB,OAAO,IAAIK,CAAC,IAAI,GACpC,IAAArC,SAAA,CAAAQ,CAAC,IAAGQ,IAAI,QAAQ6B,GAAG,EAAE;IAC3B;EACF;CACD;AAEDC,OAAA,CAAApB,OAAA,GAAejB,GAAG"},"metadata":{},"sourceType":"script","externalDependencies":[]}