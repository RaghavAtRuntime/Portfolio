{"ast":null,"code":"var _a;\nimport Ajv from \"ajv\";\nimport addFormats from \"ajv-formats\";\n//import schema from '../../schema.json';\nimport schema from \"../../schema.json.js\";\nimport pkg from \"../../package.json.js\";\nimport { InvalidOptionsError, FailedYahooValidationError } from \"./errors.js\";\n// https://ajv.js.org/docs/api.html#options\nexport const ajv = new Ajv({\n  // All rules, all errors.  Don't end early after first error.\n  allErrors: true,\n  // Allow multiple non-null types, like in TypeSript.\n  allowUnionTypes: true\n});\naddFormats(ajv);\najv.addKeyword({\n  keyword: \"yahooFinanceType\",\n  modifying: true,\n  errors: true,\n  schema: true,\n  compile(schema /*, parentSchema, it */) {\n    const validate = (data, dataCtx) => {\n      const {\n        parentData,\n        parentDataProperty\n      } = dataCtx;\n      function set(value) {\n        parentData[parentDataProperty] = value;\n        return true;\n      }\n      if (schema === \"number\" || schema === \"number|null\") {\n        if (typeof data === \"number\") return true;\n        if (typeof data === \"string\") {\n          let float = Number.parseFloat(data);\n          if (Number.isNaN(float)) {\n            validate.errors = validate.errors || [];\n            validate.errors.push({\n              keyword: \"yahooFinanceType\",\n              message: \"Number.parseFloat returned NaN\",\n              params: {\n                schema,\n                data\n              }\n            });\n            return false;\n          }\n          return set(float);\n        }\n        if (data === null) {\n          if (schema === \"number|null\") {\n            return true;\n          } else {\n            validate.errors = validate.errors || [];\n            validate.errors.push({\n              keyword: \"yahooFinanceType\",\n              message: \"Expecting number'ish but got null\",\n              params: {\n                schema,\n                data\n              }\n            });\n            return false;\n          }\n        }\n        if (typeof data === \"object\") {\n          if (Object.keys(data).length === 0) {\n            // Value of {} becomes null\n            // Note, TypeScript types should be \"number | null\"\n            if (schema === \"number|null\") {\n              return set(null);\n            } else {\n              validate.errors = validate.errors || [];\n              validate.errors.push({\n                keyword: \"yahooFinanceType\",\n                message: \"Got {}->null for 'number', did you want 'number | null' ?\",\n                params: {\n                  schema,\n                  data\n                }\n              });\n              return false;\n            }\n          }\n          if (typeof data.raw === \"number\") return set(data.raw);\n        }\n      } else if (schema === \"date\" || schema === \"date|null\") {\n        if (data instanceof Date) {\n          // Validate existing date objects.\n          // Generally we receive JSON but in the case of \"historical\", the\n          // csv parser does the date conversion, and we want to validate\n          // afterwards.\n          return true;\n        }\n        if (typeof data === \"number\") return set(new Date(data * 1000));\n        if (data === null) {\n          if (schema === \"date|null\") {\n            return true;\n          } else {\n            validate.errors = validate.errors || [];\n            validate.errors.push({\n              keyword: \"yahooFinanceType\",\n              message: \"Expecting date'ish but got null\",\n              params: {\n                schema,\n                data\n              }\n            });\n            return false;\n          }\n        }\n        if (typeof data === \"object\") {\n          if (Object.keys(data).length === 0) {\n            // Value of {} becomes null\n            // Note, TypeScript types should be \"data | null\"\n            if (schema === \"date|null\") {\n              return set(null);\n            } else {\n              validate.errors = validate.errors || [];\n              validate.errors.push({\n                keyword: \"yahooFinanceType\",\n                message: \"Got {}->null for 'date', did you want 'date | null' ?\",\n                params: {\n                  schema,\n                  data\n                }\n              });\n              return false;\n            }\n          }\n          if (typeof data.raw === \"number\") return set(new Date(data.raw * 1000));\n        }\n        if (typeof data === \"string\") {\n          if (data.match(/^\\d{4,4}-\\d{2,2}-\\d{2,2}$/) || data.match(/^\\d{4,4}-\\d{2,2}-\\d{2,2}T\\d{2,2}:\\d{2,2}:\\d{2,2}(\\.\\d{3,3})?Z$/)) return set(new Date(data));\n        }\n      } else if (schema === \"DateInMs\") {\n        return set(new Date(data));\n      } else if (schema === \"TwoNumberRange\") {\n        if (typeof data === \"object\" && typeof data.low === \"number\" && typeof data.high === \"number\") return true;\n        if (typeof data === \"string\") {\n          const parts = data.split(\"-\").map(parseFloat);\n          if (Number.isNaN(parts[0]) || Number.isNaN(parts[1])) {\n            validate.errors = validate.errors || [];\n            validate.errors.push({\n              keyword: \"yahooFinanceType\",\n              message: \"Number.parseFloat returned NaN: [\" + parts.join(\",\") + \"]\",\n              params: {\n                schema,\n                data\n              }\n            });\n            return false;\n          }\n          return set({\n            low: parts[0],\n            high: parts[1]\n          });\n        }\n      } else {\n        throw new Error(\"No such yahooFinanceType: \" + schema);\n      }\n      validate.errors = validate.errors || [];\n      validate.errors.push({\n        keyword: \"yahooFinanceType\",\n        message: \"No matching type\",\n        params: {\n          schema,\n          data\n        }\n      });\n      return false;\n    };\n    return validate;\n  }\n});\najv.addSchema(schema);\n/* istanbul ignore next */\nconst logObj = typeof process !== \"undefined\" && ((_a = process === null || process === void 0 ? void 0 : process.stdout) === null || _a === void 0 ? void 0 : _a.isTTY) ? obj => console.dir(obj, {\n  depth: 4,\n  colors: true\n}) : obj => console.log(JSON.stringify(obj, null, 2));\nexport function resolvePath(obj, instancePath) {\n  const path = instancePath.split(\"/\");\n  let ref = obj;\n  for (let i = 1; i < path.length; i++) ref = ref[path[i]];\n  return ref;\n}\nfunction disallowAdditionalProps(show = false) {\n  const disallowed = new Set();\n  // @ts-ignore: this can cause a breaking catch-22 on schema generation\n  for (let key of Object.keys(schema.definitions)) {\n    if (key.match(/Options$/)) {\n      continue;\n    }\n    // @ts-ignore\n    const def = schema.definitions[key];\n    if (def.type === \"object\" && def.additionalProperties === undefined) {\n      def.additionalProperties = false;\n      disallowed.add(key);\n    }\n  }\n  /* istanbul ignore next */\n  if (show) console.log(\"Disallowed additional props in \" + Array.from(disallowed).join(\", \"));\n}\nif (process.env.NODE_ENV === \"test\") disallowAdditionalProps();\nfunction validate({\n  source,\n  type,\n  object,\n  schemaKey,\n  options\n}) {\n  const validator = ajv.getSchema(schemaKey);\n  if (!validator) throw new Error(\"No such schema with key: \" + schemaKey);\n  const valid = validator(object);\n  if (valid) return;\n  if (type === \"result\") {\n    /* istanbul ignore else */\n    if (validator.errors) {\n      let origData = false;\n      validator.errors.forEach(error => {\n        // For now let's ignore the base object which could be huge.\n        /* istanbul ignore else */\n        if (error.instancePath !== \"\")\n          // Note, not the regular ajv data value from verbose:true\n          error.data = resolvePath(object, error.instancePath);\n        if (error.schemaPath === \"#/anyOf\") {\n          if (origData === false) {\n            origData = error.data;\n          } else if (origData === error.data) {\n            error.data = \"[shortened by validateAndCoerceTypes]\";\n          }\n        }\n      });\n      // Becaue of the \"anyOf\" in quote, errors are huuuuge and mostly\n      // irrelevant... so let's filter out (some of) the latter\n      validator.errors = validator.errors.filter(error => {\n        var _a, _b;\n        if (error.schemaPath.startsWith(\"#/definitions/Quote\")) {\n          const schemaQuoteType = error.schemaPath.substring(19).split(\"/\")[0].toUpperCase();\n          /*\n           * Filter out entries for non-matching schema type, i.e.\n           * {\n           *   schemaPath: '#/definitions/QuoteCryptoCurrency/properties...'\n           *   data: {\n           *     quoteType: \"EQUITY\"\n           *   }\n           * }\n           */\n          if (typeof error.data === \"object\" &&\n          // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n          // @ts-ignore: Properrty \"quoteType\" does not exist on type \"object\"\n          ((_a = error.data) === null || _a === void 0 ? void 0 : _a.quoteType) !== schemaQuoteType) return false;\n          /*\n           * Filter out the non-matching \"const\" for the above.\n           * {\n           *   schemaPath: '#/definitions/QuoteCryptoCurrency/properties/quoteType/const'\n           *   keyword: \"const\",\n           *   params: { allowedValue: \"CRYPTOCURRENCY\"}},\n           *   data: \"EQUITY\"\n           * }\n           */\n          if (typeof error.data === \"string\" && ((_b = error.params) === null || _b === void 0 ? void 0 : _b.allowedValue) === schemaQuoteType) return false;\n        }\n        return true;\n      });\n      // In the case of there being NO match in #anyOf, bring back the data\n      if (validator.errors.length === 1 && validator.errors[0].schemaPath === \"#/anyOf\") validator.errors[0].data = origData;\n    }\n    if (options.logErrors === true) {\n      const title = encodeURIComponent(\"Failed validation: \" + schemaKey);\n      console.log(\"The following result did not validate with schema: \" + schemaKey);\n      logObj(validator.errors);\n      // logObj(object);\n      console.log(`\nThis may happen intermittently and you should catch errors appropriately.\nHowever:  1) if this recently started happening on every request for a symbol\nthat used to work, Yahoo may have changed their API.  2) If this happens on\nevery request for a symbol you've never used before, but not for other\nsymbols, you've found an edge-case (OR, we may just be protecting you from\n\"bad\" data sometimes stored for e.g. misspelt symbols on Yahoo's side).\nPlease see if anyone has reported this previously:\n\n  ${pkg.repository}/issues?q=is%3Aissue+${title}\n\nor open a new issue (and mention the symbol):  ${pkg.name} v${pkg.version}\n\n  ${pkg.repository}/issues/new?labels=bug%2C+validation&template=validation.md&title=${title}\n\nFor information on how to turn off the above logging or skip these errors,\nsee https://github.com/gadicc/node-yahoo-finance2/tree/devel/docs/validation.md.\n\nAt the end of the doc, there's also a section on how to\n[Help Fix Validation Errors](https://github.com/gadicc/node-yahoo-finance2/blob/devel/docs/validation.md#help-fix)\nin case you'd like to contribute to the project.  Most of the time, these\nfixes are very quick and easy; it's just hard for our small core team to keep up,\nso help is always appreciated!\n`);\n    } /* if (logErrors) */\n    throw new FailedYahooValidationError(\"Failed Yahoo Schema validation\", {\n      result: object,\n      errors: validator.errors\n    });\n  } /* if (type === 'options') */else {\n    if (options.logOptionsErrors === true) {\n      console.error(`[yahooFinance.${source}] Invalid options (\"${schemaKey}\")`);\n      logObj({\n        errors: validator.errors,\n        input: object\n      });\n    }\n    throw new InvalidOptionsError(`yahooFinance.${source} called with invalid options.`);\n  }\n}\nexport { disallowAdditionalProps };\nexport default validate;","map":{"version":3,"names":["_a","Ajv","addFormats","schema","pkg","InvalidOptionsError","FailedYahooValidationError","ajv","allErrors","allowUnionTypes","addKeyword","keyword","modifying","errors","compile","validate","data","dataCtx","parentData","parentDataProperty","set","value","float","Number","parseFloat","isNaN","push","message","params","Object","keys","length","raw","Date","match","low","high","parts","split","map","join","Error","addSchema","logObj","process","stdout","isTTY","obj","console","dir","depth","colors","log","JSON","stringify","resolvePath","instancePath","path","ref","i","disallowAdditionalProps","show","disallowed","Set","key","definitions","def","type","additionalProperties","undefined","add","Array","from","env","NODE_ENV","source","object","schemaKey","options","validator","getSchema","valid","origData","forEach","error","schemaPath","filter","_b","startsWith","schemaQuoteType","substring","toUpperCase","quoteType","allowedValue","logErrors","title","encodeURIComponent","repository","name","version","result","logOptionsErrors","input"],"sources":["/Users/raghavsinha/sandbox/node_modules/yahoo-finance2/dist/esm/src/lib/validateAndCoerceTypes.js"],"sourcesContent":["var _a;\nimport Ajv from \"ajv\";\nimport addFormats from \"ajv-formats\";\n//import schema from '../../schema.json';\nimport schema from \"../../schema.json.js\";\nimport pkg from \"../../package.json.js\";\nimport { InvalidOptionsError, FailedYahooValidationError } from \"./errors.js\";\n// https://ajv.js.org/docs/api.html#options\nexport const ajv = new Ajv({\n    // All rules, all errors.  Don't end early after first error.\n    allErrors: true,\n    // Allow multiple non-null types, like in TypeSript.\n    allowUnionTypes: true,\n});\naddFormats(ajv);\najv.addKeyword({\n    keyword: \"yahooFinanceType\",\n    modifying: true,\n    errors: true,\n    schema: true,\n    compile(schema /*, parentSchema, it */) {\n        const validate = (data, dataCtx) => {\n            const { parentData, parentDataProperty } = dataCtx;\n            function set(value) {\n                parentData[parentDataProperty] = value;\n                return true;\n            }\n            if (schema === \"number\" || schema === \"number|null\") {\n                if (typeof data === \"number\")\n                    return true;\n                if (typeof data === \"string\") {\n                    let float = Number.parseFloat(data);\n                    if (Number.isNaN(float)) {\n                        validate.errors = validate.errors || [];\n                        validate.errors.push({\n                            keyword: \"yahooFinanceType\",\n                            message: \"Number.parseFloat returned NaN\",\n                            params: { schema, data },\n                        });\n                        return false;\n                    }\n                    return set(float);\n                }\n                if (data === null) {\n                    if (schema === \"number|null\") {\n                        return true;\n                    }\n                    else {\n                        validate.errors = validate.errors || [];\n                        validate.errors.push({\n                            keyword: \"yahooFinanceType\",\n                            message: \"Expecting number'ish but got null\",\n                            params: { schema, data },\n                        });\n                        return false;\n                    }\n                }\n                if (typeof data === \"object\") {\n                    if (Object.keys(data).length === 0) {\n                        // Value of {} becomes null\n                        // Note, TypeScript types should be \"number | null\"\n                        if (schema === \"number|null\") {\n                            return set(null);\n                        }\n                        else {\n                            validate.errors = validate.errors || [];\n                            validate.errors.push({\n                                keyword: \"yahooFinanceType\",\n                                message: \"Got {}->null for 'number', did you want 'number | null' ?\",\n                                params: { schema, data },\n                            });\n                            return false;\n                        }\n                    }\n                    if (typeof data.raw === \"number\")\n                        return set(data.raw);\n                }\n            }\n            else if (schema === \"date\" || schema === \"date|null\") {\n                if (data instanceof Date) {\n                    // Validate existing date objects.\n                    // Generally we receive JSON but in the case of \"historical\", the\n                    // csv parser does the date conversion, and we want to validate\n                    // afterwards.\n                    return true;\n                }\n                if (typeof data === \"number\")\n                    return set(new Date(data * 1000));\n                if (data === null) {\n                    if (schema === \"date|null\") {\n                        return true;\n                    }\n                    else {\n                        validate.errors = validate.errors || [];\n                        validate.errors.push({\n                            keyword: \"yahooFinanceType\",\n                            message: \"Expecting date'ish but got null\",\n                            params: { schema, data },\n                        });\n                        return false;\n                    }\n                }\n                if (typeof data === \"object\") {\n                    if (Object.keys(data).length === 0) {\n                        // Value of {} becomes null\n                        // Note, TypeScript types should be \"data | null\"\n                        if (schema === \"date|null\") {\n                            return set(null);\n                        }\n                        else {\n                            validate.errors = validate.errors || [];\n                            validate.errors.push({\n                                keyword: \"yahooFinanceType\",\n                                message: \"Got {}->null for 'date', did you want 'date | null' ?\",\n                                params: { schema, data },\n                            });\n                            return false;\n                        }\n                    }\n                    if (typeof data.raw === \"number\")\n                        return set(new Date(data.raw * 1000));\n                }\n                if (typeof data === \"string\") {\n                    if (data.match(/^\\d{4,4}-\\d{2,2}-\\d{2,2}$/) ||\n                        data.match(/^\\d{4,4}-\\d{2,2}-\\d{2,2}T\\d{2,2}:\\d{2,2}:\\d{2,2}(\\.\\d{3,3})?Z$/))\n                        return set(new Date(data));\n                }\n            }\n            else if (schema === \"DateInMs\") {\n                return set(new Date(data));\n            }\n            else if (schema === \"TwoNumberRange\") {\n                if (typeof data === \"object\" &&\n                    typeof data.low === \"number\" &&\n                    typeof data.high === \"number\")\n                    return true;\n                if (typeof data === \"string\") {\n                    const parts = data.split(\"-\").map(parseFloat);\n                    if (Number.isNaN(parts[0]) || Number.isNaN(parts[1])) {\n                        validate.errors = validate.errors || [];\n                        validate.errors.push({\n                            keyword: \"yahooFinanceType\",\n                            message: \"Number.parseFloat returned NaN: [\" + parts.join(\",\") + \"]\",\n                            params: { schema, data },\n                        });\n                        return false;\n                    }\n                    return set({ low: parts[0], high: parts[1] });\n                }\n            }\n            else {\n                throw new Error(\"No such yahooFinanceType: \" + schema);\n            }\n            validate.errors = validate.errors || [];\n            validate.errors.push({\n                keyword: \"yahooFinanceType\",\n                message: \"No matching type\",\n                params: { schema, data },\n            });\n            return false;\n        };\n        return validate;\n    },\n});\najv.addSchema(schema);\n/* istanbul ignore next */\nconst logObj = typeof process !== \"undefined\" && ((_a = process === null || process === void 0 ? void 0 : process.stdout) === null || _a === void 0 ? void 0 : _a.isTTY)\n    ? (obj) => console.dir(obj, { depth: 4, colors: true })\n    : (obj) => console.log(JSON.stringify(obj, null, 2));\nexport function resolvePath(obj, instancePath) {\n    const path = instancePath.split(\"/\");\n    let ref = obj;\n    for (let i = 1; i < path.length; i++)\n        ref = ref[path[i]];\n    return ref;\n}\nfunction disallowAdditionalProps(show = false) {\n    const disallowed = new Set();\n    // @ts-ignore: this can cause a breaking catch-22 on schema generation\n    for (let key of Object.keys(schema.definitions)) {\n        if (key.match(/Options$/)) {\n            continue;\n        }\n        // @ts-ignore\n        const def = schema.definitions[key];\n        if (def.type === \"object\" && def.additionalProperties === undefined) {\n            def.additionalProperties = false;\n            disallowed.add(key);\n        }\n    }\n    /* istanbul ignore next */\n    if (show)\n        console.log(\"Disallowed additional props in \" + Array.from(disallowed).join(\", \"));\n}\nif (process.env.NODE_ENV === \"test\")\n    disallowAdditionalProps();\nfunction validate({ source, type, object, schemaKey, options, }) {\n    const validator = ajv.getSchema(schemaKey);\n    if (!validator)\n        throw new Error(\"No such schema with key: \" + schemaKey);\n    const valid = validator(object);\n    if (valid)\n        return;\n    if (type === \"result\") {\n        /* istanbul ignore else */\n        if (validator.errors) {\n            let origData = false;\n            validator.errors.forEach((error) => {\n                // For now let's ignore the base object which could be huge.\n                /* istanbul ignore else */\n                if (error.instancePath !== \"\")\n                    // Note, not the regular ajv data value from verbose:true\n                    error.data = resolvePath(object, error.instancePath);\n                if (error.schemaPath === \"#/anyOf\") {\n                    if (origData === false) {\n                        origData = error.data;\n                    }\n                    else if (origData === error.data) {\n                        error.data = \"[shortened by validateAndCoerceTypes]\";\n                    }\n                }\n            });\n            // Becaue of the \"anyOf\" in quote, errors are huuuuge and mostly\n            // irrelevant... so let's filter out (some of) the latter\n            validator.errors = validator.errors.filter((error) => {\n                var _a, _b;\n                if (error.schemaPath.startsWith(\"#/definitions/Quote\")) {\n                    const schemaQuoteType = error.schemaPath\n                        .substring(19)\n                        .split(\"/\")[0]\n                        .toUpperCase();\n                    /*\n                     * Filter out entries for non-matching schema type, i.e.\n                     * {\n                     *   schemaPath: '#/definitions/QuoteCryptoCurrency/properties...'\n                     *   data: {\n                     *     quoteType: \"EQUITY\"\n                     *   }\n                     * }\n                     */\n                    if (typeof error.data === \"object\" &&\n                        // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n                        // @ts-ignore: Properrty \"quoteType\" does not exist on type \"object\"\n                        ((_a = error.data) === null || _a === void 0 ? void 0 : _a.quoteType) !== schemaQuoteType)\n                        return false;\n                    /*\n                     * Filter out the non-matching \"const\" for the above.\n                     * {\n                     *   schemaPath: '#/definitions/QuoteCryptoCurrency/properties/quoteType/const'\n                     *   keyword: \"const\",\n                     *   params: { allowedValue: \"CRYPTOCURRENCY\"}},\n                     *   data: \"EQUITY\"\n                     * }\n                     */\n                    if (typeof error.data === \"string\" &&\n                        ((_b = error.params) === null || _b === void 0 ? void 0 : _b.allowedValue) === schemaQuoteType)\n                        return false;\n                }\n                return true;\n            });\n            // In the case of there being NO match in #anyOf, bring back the data\n            if (validator.errors.length === 1 &&\n                validator.errors[0].schemaPath === \"#/anyOf\")\n                validator.errors[0].data = origData;\n        }\n        if (options.logErrors === true) {\n            const title = encodeURIComponent(\"Failed validation: \" + schemaKey);\n            console.log(\"The following result did not validate with schema: \" + schemaKey);\n            logObj(validator.errors);\n            // logObj(object);\n            console.log(`\nThis may happen intermittently and you should catch errors appropriately.\nHowever:  1) if this recently started happening on every request for a symbol\nthat used to work, Yahoo may have changed their API.  2) If this happens on\nevery request for a symbol you've never used before, but not for other\nsymbols, you've found an edge-case (OR, we may just be protecting you from\n\"bad\" data sometimes stored for e.g. misspelt symbols on Yahoo's side).\nPlease see if anyone has reported this previously:\n\n  ${pkg.repository}/issues?q=is%3Aissue+${title}\n\nor open a new issue (and mention the symbol):  ${pkg.name} v${pkg.version}\n\n  ${pkg.repository}/issues/new?labels=bug%2C+validation&template=validation.md&title=${title}\n\nFor information on how to turn off the above logging or skip these errors,\nsee https://github.com/gadicc/node-yahoo-finance2/tree/devel/docs/validation.md.\n\nAt the end of the doc, there's also a section on how to\n[Help Fix Validation Errors](https://github.com/gadicc/node-yahoo-finance2/blob/devel/docs/validation.md#help-fix)\nin case you'd like to contribute to the project.  Most of the time, these\nfixes are very quick and easy; it's just hard for our small core team to keep up,\nso help is always appreciated!\n`);\n        } /* if (logErrors) */\n        throw new FailedYahooValidationError(\"Failed Yahoo Schema validation\", {\n            result: object,\n            errors: validator.errors,\n        });\n    } /* if (type === 'options') */\n    else {\n        if (options.logOptionsErrors === true) {\n            console.error(`[yahooFinance.${source}] Invalid options (\"${schemaKey}\")`);\n            logObj({ errors: validator.errors, input: object });\n        }\n        throw new InvalidOptionsError(`yahooFinance.${source} called with invalid options.`);\n    }\n}\nexport { disallowAdditionalProps };\nexport default validate;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}