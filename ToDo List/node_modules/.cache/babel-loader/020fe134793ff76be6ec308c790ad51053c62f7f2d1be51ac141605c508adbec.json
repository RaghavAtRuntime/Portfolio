{"ast":null,"code":"import Timeseries_Keys from \"../lib/timeseries.json.js\";\nexport const FundamentalsTimeSeries_Types = [\"quarterly\", \"annual\", \"trailing\"];\nexport const FundamentalsTimeSeries_Modules = [\"financials\", \"balance-sheet\", \"cash-flow\", \"all\"];\nconst queryOptionsDefaults = {\n  merge: false,\n  padTimeSeries: true,\n  lang: \"en-US\",\n  region: \"US\",\n  type: \"quarterly\"\n};\nexport default function fundamentalsTimeSeries(symbol, queryOptionsOverrides, moduleOptions) {\n  return this._moduleExec({\n    moduleName: \"options\",\n    query: {\n      assertSymbol: symbol,\n      url: `https://query1.finance.yahoo.com/ws/fundamentals-timeseries/v1/finance/timeseries/${symbol}`,\n      needsCrumb: false,\n      schemaKey: \"#/definitions/FundamentalsTimeSeriesOptions\",\n      defaults: queryOptionsDefaults,\n      overrides: queryOptionsOverrides,\n      transformWith: processQuery\n    },\n    result: {\n      schemaKey: \"#/definitions/FundamentalsTimeSeriesResults\",\n      transformWith(response) {\n        if (!response || !response.timeseries) throw new Error(`Unexpected result: ${JSON.stringify(response)}`);\n        return processResponse(response);\n      }\n    },\n    moduleOptions\n  });\n}\n/**\n * Transform the input options into query parameters.\n * The options module defines which keys that are used in the query.\n * The keys are joined together into the query parameter type and\n * pre-fixed with the options type (e.g. annualTotalRevenue).\n * @param queryOptions Input query options.\n * @returns Query parameters.\n */\nexport const processQuery = function (queryOptions) {\n  // Convert dates\n  if (!queryOptions.period2) queryOptions.period2 = new Date();\n  const dates = [\"period1\", \"period2\"];\n  for (const fieldName of dates) {\n    const value = queryOptions[fieldName];\n    if (value instanceof Date) queryOptions[fieldName] = Math.floor(value.getTime() / 1000);else if (typeof value === \"string\") {\n      const timestamp = new Date(value).getTime();\n      if (isNaN(timestamp)) throw new Error(\"yahooFinance.fundamentalsTimeSeries() option '\" + fieldName + \"' invalid date provided: '\" + value + \"'\");\n      queryOptions[fieldName] = Math.floor(timestamp / 1000);\n    }\n  }\n  // Validate query parameters.\n  if (queryOptions.period1 === queryOptions.period2) {\n    throw new Error(\"yahooFinance.fundamentalsTimeSeries() options `period1` and `period2` \" + \"cannot share the same value.\");\n  } else if (!FundamentalsTimeSeries_Types.includes(queryOptions.type || \"\")) {\n    throw new Error(\"yahooFinance.fundamentalsTimeSeries() option type invalid.\");\n  } else if (!FundamentalsTimeSeries_Modules.includes(queryOptions.module || \"\")) {\n    throw new Error(\"yahooFinance.fundamentalsTimeSeries() option module invalid.\");\n  }\n  // Join the keys for the module into query types.\n  const keys = Object.entries(Timeseries_Keys).reduce((previous, [module, keys]) => {\n    if (queryOptions.module == \"all\") {\n      return previous.concat(keys);\n    } else if (module == queryOptions.module) {\n      return previous.concat(keys);\n    } else return previous;\n  }, []);\n  const queryType = queryOptions.type + keys.join(`,${queryOptions.type}`);\n  return {\n    period1: queryOptions.period1,\n    period2: queryOptions.period2,\n    type: queryType\n  };\n};\n/**\n * Transforms the time-series into an array with reported values per period.\n * Each object represents a period and its properties are the data points.\n * Financial statement content variates and keys are skipped when empty.\n * The query keys include the option type  (e.g. annualTotalRevenue).\n * In the response the type is removed (e.g. totalRevenue) for\n * easier mapping by the client.\n * @param response Query response.\n * @returns Formatted response.\n */\nexport const processResponse = function (response) {\n  const keyedByTimestamp = {};\n  const replace = new RegExp(FundamentalsTimeSeries_Types.join(\"|\"));\n  for (let ct = 0; ct < response.timeseries.result.length; ct++) {\n    const result = response.timeseries.result[ct];\n    if (!result.timestamp || !result.timestamp.length) {\n      continue;\n    }\n    for (let ct = 0; ct < result.timestamp.length; ct++) {\n      const timestamp = result.timestamp[ct];\n      const dataKey = Object.keys(result)[2];\n      if (!keyedByTimestamp[timestamp]) {\n        keyedByTimestamp[timestamp] = {\n          date: timestamp\n        };\n      }\n      if (!result[dataKey][ct] || !result[dataKey][ct].reportedValue || !result[dataKey][ct].reportedValue.raw) {\n        continue;\n      }\n      const short = dataKey.replace(replace, \"\");\n      const key = short == short.toUpperCase() ? short : short[0].toLowerCase() + short.slice(1);\n      keyedByTimestamp[timestamp][key] = result[dataKey][ct].reportedValue.raw;\n    }\n  }\n  return Object.keys(keyedByTimestamp).map(k => keyedByTimestamp[k]);\n};","map":{"version":3,"names":["Timeseries_Keys","FundamentalsTimeSeries_Types","FundamentalsTimeSeries_Modules","queryOptionsDefaults","merge","padTimeSeries","lang","region","type","fundamentalsTimeSeries","symbol","queryOptionsOverrides","moduleOptions","_moduleExec","moduleName","query","assertSymbol","url","needsCrumb","schemaKey","defaults","overrides","transformWith","processQuery","result","response","timeseries","Error","JSON","stringify","processResponse","queryOptions","period2","Date","dates","fieldName","value","Math","floor","getTime","timestamp","isNaN","period1","includes","module","keys","Object","entries","reduce","previous","concat","queryType","join","keyedByTimestamp","replace","RegExp","ct","length","dataKey","date","reportedValue","raw","short","key","toUpperCase","toLowerCase","slice","map","k"],"sources":["/Users/raghavsinha/sandbox/node_modules/yahoo-finance2/dist/esm/src/modules/fundamentalsTimeSeries.js"],"sourcesContent":["import Timeseries_Keys from \"../lib/timeseries.json.js\";\nexport const FundamentalsTimeSeries_Types = [\"quarterly\", \"annual\", \"trailing\"];\nexport const FundamentalsTimeSeries_Modules = [\n    \"financials\",\n    \"balance-sheet\",\n    \"cash-flow\",\n    \"all\",\n];\nconst queryOptionsDefaults = {\n    merge: false,\n    padTimeSeries: true,\n    lang: \"en-US\",\n    region: \"US\",\n    type: \"quarterly\",\n};\nexport default function fundamentalsTimeSeries(symbol, queryOptionsOverrides, moduleOptions) {\n    return this._moduleExec({\n        moduleName: \"options\",\n        query: {\n            assertSymbol: symbol,\n            url: `https://query1.finance.yahoo.com/ws/fundamentals-timeseries/v1/finance/timeseries/${symbol}`,\n            needsCrumb: false,\n            schemaKey: \"#/definitions/FundamentalsTimeSeriesOptions\",\n            defaults: queryOptionsDefaults,\n            overrides: queryOptionsOverrides,\n            transformWith: processQuery,\n        },\n        result: {\n            schemaKey: \"#/definitions/FundamentalsTimeSeriesResults\",\n            transformWith(response) {\n                if (!response || !response.timeseries)\n                    throw new Error(`Unexpected result: ${JSON.stringify(response)}`);\n                return processResponse(response);\n            },\n        },\n        moduleOptions,\n    });\n}\n/**\n * Transform the input options into query parameters.\n * The options module defines which keys that are used in the query.\n * The keys are joined together into the query parameter type and\n * pre-fixed with the options type (e.g. annualTotalRevenue).\n * @param queryOptions Input query options.\n * @returns Query parameters.\n */\nexport const processQuery = function (queryOptions) {\n    // Convert dates\n    if (!queryOptions.period2)\n        queryOptions.period2 = new Date();\n    const dates = [\"period1\", \"period2\"];\n    for (const fieldName of dates) {\n        const value = queryOptions[fieldName];\n        if (value instanceof Date)\n            queryOptions[fieldName] = Math.floor(value.getTime() / 1000);\n        else if (typeof value === \"string\") {\n            const timestamp = new Date(value).getTime();\n            if (isNaN(timestamp))\n                throw new Error(\"yahooFinance.fundamentalsTimeSeries() option '\" +\n                    fieldName +\n                    \"' invalid date provided: '\" +\n                    value +\n                    \"'\");\n            queryOptions[fieldName] = Math.floor(timestamp / 1000);\n        }\n    }\n    // Validate query parameters.\n    if (queryOptions.period1 === queryOptions.period2) {\n        throw new Error(\"yahooFinance.fundamentalsTimeSeries() options `period1` and `period2` \" +\n            \"cannot share the same value.\");\n    }\n    else if (!FundamentalsTimeSeries_Types.includes(queryOptions.type || \"\")) {\n        throw new Error(\"yahooFinance.fundamentalsTimeSeries() option type invalid.\");\n    }\n    else if (!FundamentalsTimeSeries_Modules.includes(queryOptions.module || \"\")) {\n        throw new Error(\"yahooFinance.fundamentalsTimeSeries() option module invalid.\");\n    }\n    // Join the keys for the module into query types.\n    const keys = Object.entries(Timeseries_Keys).reduce((previous, [module, keys]) => {\n        if (queryOptions.module == \"all\") {\n            return previous.concat(keys);\n        }\n        else if (module == queryOptions.module) {\n            return previous.concat(keys);\n        }\n        else\n            return previous;\n    }, []);\n    const queryType = queryOptions.type + keys.join(`,${queryOptions.type}`);\n    return {\n        period1: queryOptions.period1,\n        period2: queryOptions.period2,\n        type: queryType,\n    };\n};\n/**\n * Transforms the time-series into an array with reported values per period.\n * Each object represents a period and its properties are the data points.\n * Financial statement content variates and keys are skipped when empty.\n * The query keys include the option type  (e.g. annualTotalRevenue).\n * In the response the type is removed (e.g. totalRevenue) for\n * easier mapping by the client.\n * @param response Query response.\n * @returns Formatted response.\n */\nexport const processResponse = function (response) {\n    const keyedByTimestamp = {};\n    const replace = new RegExp(FundamentalsTimeSeries_Types.join(\"|\"));\n    for (let ct = 0; ct < response.timeseries.result.length; ct++) {\n        const result = response.timeseries.result[ct];\n        if (!result.timestamp || !result.timestamp.length) {\n            continue;\n        }\n        for (let ct = 0; ct < result.timestamp.length; ct++) {\n            const timestamp = result.timestamp[ct];\n            const dataKey = Object.keys(result)[2];\n            if (!keyedByTimestamp[timestamp]) {\n                keyedByTimestamp[timestamp] = { date: timestamp };\n            }\n            if (!result[dataKey][ct] ||\n                !result[dataKey][ct].reportedValue ||\n                !result[dataKey][ct].reportedValue.raw) {\n                continue;\n            }\n            const short = dataKey.replace(replace, \"\");\n            const key = short == short.toUpperCase()\n                ? short\n                : short[0].toLowerCase() + short.slice(1);\n            keyedByTimestamp[timestamp][key] = result[dataKey][ct].reportedValue.raw;\n        }\n    }\n    return Object.keys(keyedByTimestamp).map((k) => keyedByTimestamp[k]);\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}