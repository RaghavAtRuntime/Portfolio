{"ast":null,"code":"const queryOptionsDefaults = {\n  interval: \"1d\",\n  events: \"history\",\n  includeAdjustedClose: true\n};\nexport default function historical(symbol, queryOptionsOverrides, moduleOptions) {\n  let schemaKey;\n  if (!queryOptionsOverrides.events || queryOptionsOverrides.events === \"history\") schemaKey = \"#/definitions/HistoricalHistoryResult\";else if (queryOptionsOverrides.events === \"dividends\") schemaKey = \"#/definitions/HistoricalDividendsResult\";else if (queryOptionsOverrides.events === \"split\") schemaKey = \"#/definitions/HistoricalStockSplitsResult\";else throw new Error(\"No such event type:\" + queryOptionsOverrides.events);\n  return this._moduleExec({\n    moduleName: \"historical\",\n    query: {\n      assertSymbol: symbol,\n      url: \"https://${YF_QUERY_HOST}/v7/finance/download/\" + symbol,\n      schemaKey: \"#/definitions/HistoricalOptions\",\n      defaults: queryOptionsDefaults,\n      overrides: queryOptionsOverrides,\n      fetchType: \"csv\",\n      transformWith(queryOptions) {\n        if (!queryOptions.period2) queryOptions.period2 = new Date();\n        const dates = [\"period1\", \"period2\"];\n        for (const fieldName of dates) {\n          const value = queryOptions[fieldName];\n          if (value instanceof Date) queryOptions[fieldName] = Math.floor(value.getTime() / 1000);else if (typeof value === \"string\") {\n            const timestamp = new Date(value).getTime();\n            if (isNaN(timestamp)) throw new Error(\"yahooFinance.historical() option '\" + fieldName + \"' invalid date provided: '\" + value + \"'\");\n            queryOptions[fieldName] = Math.floor(timestamp / 1000);\n          }\n        }\n        if (queryOptions.period1 === queryOptions.period2) {\n          throw new Error(\"yahooFinance.historical() options `period1` and `period2` \" + \"cannot share the same value.\");\n        }\n        return queryOptions;\n      }\n    },\n    result: {\n      schemaKey,\n      transformWith(result) {\n        if (result.length === 0) return result;\n        const filteredResults = [];\n        const fieldCount = Object.keys(result[0]).length;\n        // Count number of null values in object (1-level deep)\n        function nullFieldCount(object) {\n          let nullCount = 0;\n          for (const val of Object.values(object)) if (val === null) nullCount++;\n          return nullCount;\n        }\n        for (const row of result) {\n          const nullCount = nullFieldCount(row);\n          if (nullCount === 0) {\n            // No nulls is a legit (regular) result\n            filteredResults.push(row);\n          } else if (nullCount !== fieldCount - 1 /* skip \"date\" */) {\n            // Unhandled case: some but not all values are null.\n            // Note: no need to check for null \"date\", validation does it for us\n            console.error(nullCount, row);\n            throw new Error(\"Historical returned a result with SOME (but not \" + \"all) null values.  Please report this, and provide the \" + \"query that caused it.\");\n          } else {\n            // All fields (except \"date\") are null: silently skip (no-op)\n          }\n        }\n        /*\n         * We may consider, for future optimization, to count rows and create\n         * new array in advance, and skip consecutive blocks of null results.\n         * Of doubtful utility.\n         */\n        return filteredResults;\n      }\n    },\n    moduleOptions\n  });\n}","map":{"version":3,"names":["queryOptionsDefaults","interval","events","includeAdjustedClose","historical","symbol","queryOptionsOverrides","moduleOptions","schemaKey","Error","_moduleExec","moduleName","query","assertSymbol","url","defaults","overrides","fetchType","transformWith","queryOptions","period2","Date","dates","fieldName","value","Math","floor","getTime","timestamp","isNaN","period1","result","length","filteredResults","fieldCount","Object","keys","nullFieldCount","object","nullCount","val","values","row","push","console","error"],"sources":["/Users/raghavsinha/sandbox/node_modules/yahoo-finance2/dist/esm/src/modules/historical.js"],"sourcesContent":["const queryOptionsDefaults = {\n    interval: \"1d\",\n    events: \"history\",\n    includeAdjustedClose: true,\n};\nexport default function historical(symbol, queryOptionsOverrides, moduleOptions) {\n    let schemaKey;\n    if (!queryOptionsOverrides.events ||\n        queryOptionsOverrides.events === \"history\")\n        schemaKey = \"#/definitions/HistoricalHistoryResult\";\n    else if (queryOptionsOverrides.events === \"dividends\")\n        schemaKey = \"#/definitions/HistoricalDividendsResult\";\n    else if (queryOptionsOverrides.events === \"split\")\n        schemaKey = \"#/definitions/HistoricalStockSplitsResult\";\n    else\n        throw new Error(\"No such event type:\" + queryOptionsOverrides.events);\n    return this._moduleExec({\n        moduleName: \"historical\",\n        query: {\n            assertSymbol: symbol,\n            url: \"https://${YF_QUERY_HOST}/v7/finance/download/\" + symbol,\n            schemaKey: \"#/definitions/HistoricalOptions\",\n            defaults: queryOptionsDefaults,\n            overrides: queryOptionsOverrides,\n            fetchType: \"csv\",\n            transformWith(queryOptions) {\n                if (!queryOptions.period2)\n                    queryOptions.period2 = new Date();\n                const dates = [\"period1\", \"period2\"];\n                for (const fieldName of dates) {\n                    const value = queryOptions[fieldName];\n                    if (value instanceof Date)\n                        queryOptions[fieldName] = Math.floor(value.getTime() / 1000);\n                    else if (typeof value === \"string\") {\n                        const timestamp = new Date(value).getTime();\n                        if (isNaN(timestamp))\n                            throw new Error(\"yahooFinance.historical() option '\" +\n                                fieldName +\n                                \"' invalid date provided: '\" +\n                                value +\n                                \"'\");\n                        queryOptions[fieldName] = Math.floor(timestamp / 1000);\n                    }\n                }\n                if (queryOptions.period1 === queryOptions.period2) {\n                    throw new Error(\"yahooFinance.historical() options `period1` and `period2` \" +\n                        \"cannot share the same value.\");\n                }\n                return queryOptions;\n            },\n        },\n        result: {\n            schemaKey,\n            transformWith(result) {\n                if (result.length === 0)\n                    return result;\n                const filteredResults = [];\n                const fieldCount = Object.keys(result[0]).length;\n                // Count number of null values in object (1-level deep)\n                function nullFieldCount(object) {\n                    let nullCount = 0;\n                    for (const val of Object.values(object))\n                        if (val === null)\n                            nullCount++;\n                    return nullCount;\n                }\n                for (const row of result) {\n                    const nullCount = nullFieldCount(row);\n                    if (nullCount === 0) {\n                        // No nulls is a legit (regular) result\n                        filteredResults.push(row);\n                    }\n                    else if (nullCount !== fieldCount - 1 /* skip \"date\" */) {\n                        // Unhandled case: some but not all values are null.\n                        // Note: no need to check for null \"date\", validation does it for us\n                        console.error(nullCount, row);\n                        throw new Error(\"Historical returned a result with SOME (but not \" +\n                            \"all) null values.  Please report this, and provide the \" +\n                            \"query that caused it.\");\n                    }\n                    else {\n                        // All fields (except \"date\") are null: silently skip (no-op)\n                    }\n                }\n                /*\n                 * We may consider, for future optimization, to count rows and create\n                 * new array in advance, and skip consecutive blocks of null results.\n                 * Of doubtful utility.\n                 */\n                return filteredResults;\n            },\n        },\n        moduleOptions,\n    });\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}